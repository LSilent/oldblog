%title Python语言的技巧
Date:2012-11-30

注：所有技巧来自互联网，hit9只负责整理。欢迎指正错误以及不当之处，欢迎补充

[TOC]

## 1.为何python没有unzip()函数

因为zip(\*c)办到了同样的效果!

```python
>>> a,b=[1,2,3],[4,5,6]
>>> c=zip(a,b)
>>> c
[(1, 4), (2, 5), (3, 6)]
>>> zip(*c)
[(1, 2, 3), (4, 5, 6)]
>>> 
```

可以用来计算矩阵的转置矩阵

## 2.sum()函数

怎么把一个‘二层’嵌套的列表去掉内层列表。比如`[[1,2],[3]]`=>`[1,2,3]`

```python
>>> a=[[1,2,3],[4],[5,6],[7,8,9]]
>>> sum(a,[])
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

这个技巧很赞。比如我们想知道一个2D数组（矩阵）的数的和的话:

```python
>>> a=[[1,2,3],[4,5,6],[7,8,9]]
>>> sum(sum(a,[]))
45
```

## 3.判断子串

如果我们想判断一个字符串是不是另一个字符串的子串，可以使用index或者find方法:

```python
>>> 'i love u'.find('u')
7
```

更pythonic的做法是:

```python
>>> 'u' in 'my heart'
False
```

## 4.这是为什么！

看代码：
```python
>>> a=256
>>> b=256
>>> a is b
True
>>> a=257 
>>> b=257
>>> a is b
False
```
这是因为:All integers from -5 to 256 inclusive are cached as global objects 

## 5.快速列表初始化的问题

我们可以使用`[m]*n`来初始化一个n个元素都是m的列表

看下面的代码:

```python
>>> a=[[]]*4
>>> a
[[], [], [], []]
>>> a[0].append(1)
>>> a
[[1], [1], [1], [1]]
```

为什么a的每一个元素都被修改了呢？因为这样得到的列表的每个元素都是同一个对象:

```python
>>> a=[[]]*4
>>> a[0] is a[1]
True
```

## 6.iter函数的调用

```python
>>> a=[1,2,3,4]
>>> b=iter(a)
>>> list(b)
[1, 2, 3, 4]
>>> list(b)
[]
```

为何两次调用的结果不一样呢?因为b每次被调用取元素都会向下跑一位.

也就是向迭代器取元素的时候，向后推进一位并非next()函数所为，iter()函数会自动后偏一位

## 7. zip(\*[iter(x)]\*n)

首先看这么一个问题:

怎么把一个列表的n等分:

[1,2,3,4,5,6,7,8,9]=>[(1,2,3),(4,5,6),(7,8,9)] (此时n取3,列表为x)

其中一个做法就是`zip(*[iter(x)]*3)`,另一种方法是`map(None,*[iter(x)]*3)`

为何这个会起作用呢?

注意,比如我们取y=iter(x),根据第5个规律，`[iter(x)]*3`就是`[y,y,y]`.而iter()函数每次被调用都会从x取一个元素。那么对zip函数的传参列表为:

```
参数1  参数2  参数3
1      2     3             ---  第一次取元素
4      5     6             ---  第二次
7      8     9             ---  第三次
```

所以zip函数接受到的参数列表相当于:(1,4,7),(2,5,8),(3,6,9)

再根据规律1，所以得到了转置的矩阵:[(1,2,3),(4,5,6),(7,8,9)]

## 8.property装饰器

property装饰器可以让你象调用对象的属性那样调用函数:

```python
>>> class A:
...   @property
...   def foo(self):
...     return "hello"
... 
>>> A().foo
'hello'
```
