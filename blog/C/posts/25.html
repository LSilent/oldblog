<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>链表的各种题目整理(C语言实现)(Simple and Brief)</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <link rel="stylesheet" href="../../../static/style.css" type="text/css" media="screen" charset="utf-8">
        <link rel="stylesheet" href="../../../static/solarizeddark-code-style.css" type="text/css" media="screen" charset="utf-8">
        <script type="text/javascript">
            function pagenum(){return parseInt(pagename())}function pagename(){var a=window.location.href;return a.slice(a.lastIndexOf("/")+1,a.lastIndexOf("."))}function gotopre(){var a=pagename();if(a=="index"){alert("No Pre Page");return false}var d=parseInt(a);var c=(d==2)?"index.html":d-1+".html";var b=new XMLHttpRequest();b.onreadystatechange=function(){if(b.readyState==4&&b.status==404){alert("No Pre Page");return false}if(b.readyState==4&&b.status==200){location.href=c}};b.open("GET",c,true);b.send()}function gotonext(){var a=pagename();var c=(a=="index")?"2.html":parseInt(a)+1+".html";var b=new XMLHttpRequest();b.onreadystatechange=function(){if(b.readyState==4&&b.status==404){alert("No Next Page");return false}if(b.readyState==4&&b.status==200){location.href=c}};b.open("GET",c,true);b.send()};
        </script>
    </head>
    <body itemscope itemtype="http://schema.org/BlogPosting">
        <div id="top">
            <div id="top1">
                <a href="/index.html">Hit9</a>
                <a href="/blog/index.html">Blog</a>
                <a href="/wiki/index.html">Wiki</a>
                <a href="/project/index.html">Project</a>
                <a href="/links.html">Links</a>
                <a href="/dir_html.html">Archives</a>
                <a href="/About.html" rel="author publisher" itemprop="author" itemscope="" itemtype="http://schema.org/Person" >About</a>
            </div>
            <div id="top2">
                Page:
                <a href="index.html">First</a>
                <a href="../index.html">UP</a>
                <a href="javascript:void(0);" onclick="gotopre();">Pre</a>
                <a href="javascript:void(0);" onclick="gotonext()">Next</a>
                <a href="javascript:void(0);" onclick="history.go(-1);">Back</a>
            </div>
        </div>
        <h1 itemprop="headline name">链表的各种题目整理(C语言实现)(Simple and Brief)</h1>
        <!--fork me on github button-->
        <a href="https://github.com/hit9"><img style="position: absolute; top: 0; right: 0; border: 0;z-index:12" src="../../../static/img/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>
        <!--end of github fork button-->
        <p itemprop="copyrightHolder">允许转载, 但转载请注明出处</p>
        <div itemprop="articleBody">
            <p>最后更新于Date:2012-11-04</p>
<p>这里处理的全部是单链表:</p>
<div class="codehilite"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span> 
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">node_t</span><span class="p">;</span>
</pre></div>


<p>我们约定一个打印链表的函数:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">list_display</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">head</span><span class="p">;</span> <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s &quot;</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>下面是几个常见的链表笔面问题:</p>
<div class="toc">
<ul>
<li><a href="#1">1.计算链表长度</a></li>
<li><a href="#2">2.反转链表</a></li>
<li><a href="#3k0">3.查找倒数第k个元素(尾结点记为倒数第0个)</a></li>
<li><a href="#4">4.查找中间结点</a></li>
<li><a href="#5">5.逆序打印链表</a></li>
<li><a href="#6">6.判断一个链表是否有环</a></li>
<li><a href="#7">7.找出链表中环的入口结点</a></li>
<li><a href="#8">8.判断两个单链表是否相交</a></li>
<li><a href="#9">9.找两个链表相交的交点</a></li>
<li><a href="#10o1">10.O(1)删除结点(不给头结点)</a></li>
<li><a href="#11">11.两个链表右对齐打印</a></li>
</ul>
</div>
<h2 id="1">1.计算链表长度</h2>
<p>很简单:(复杂度O(n))</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">list_len</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">head</span><span class="p">;</span> <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>


<p>测试:</p>
<div class="codehilite"><pre><span class="n">int</span> <span class="n">main</span><span class="p">(</span><span class="n">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">node_t</span> <span class="n">d</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">d</span>&quot;<span class="p">,</span> 0<span class="p">},</span> <span class="n">c</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">c</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">b</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">a</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
    <span class="n">printf</span><span class="p">(</span>&quot;<span class="c">%d\n&quot;, list_len(&amp;a));//4</span>
    <span class="k">return</span> 0<span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2 id="2">2.反转链表</h2>
<p>我们多用几个指针就可以在O(n)完成反转任务:</p>
<p>算法:t遍历链表, q记录t的上一个结点, p是一个临时变量用来缓存t的值</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">t</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>


<p>测试:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">list_display</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> 
<span class="n">reverse</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> 
<span class="n">list_display</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span> 
</pre></div>


<h2 id="3k0">3.查找倒数第k个元素(尾结点记为倒数第0个)</h2>
<p>算法:2个指针p, q初始化指向头结点.p先跑到k结点处, 然后q再开始跑, 当p跑到最后跑到尾巴时, q正好到达倒数第k个.复杂度O(n)</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="o">*</span><span class="nf">_kth</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="n">node_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">);</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">q</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>


<p>测试:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;_0 :%s _1: %s _2:%s _3:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">_kth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">_kth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">_kth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">_kth</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</pre></div>


<p>输出:</p>
<div class="codehilite"><pre><span class="n">_0</span> <span class="o">:</span><span class="n">d</span> <span class="n">_1</span><span class="o">:</span> <span class="n">c</span> <span class="n">_2</span><span class="o">:</span><span class="n">b</span> <span class="n">_3</span><span class="o">:</span><span class="n">a</span>
</pre></div>


<h2 id="4">4.查找中间结点</h2>
<p>找出中间的那个结点</p>
<p>算法:设两个初始化指向头结点的指针p, q.p每次前进两个结点, q每次前进一个结点, 这样当p到达链表尾巴的时候, q到达了中间.复杂度O(n)</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="o">*</span><span class="nf">middle</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">q</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>


<p>测试:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">e</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">e</span>&quot;<span class="p">,</span> 0<span class="p">},</span> <span class="n">d</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">d</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">},</span> <span class="n">c</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">c</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">b</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">a</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">printf</span><span class="p">(</span>&quot;<span class="c">%s\n&quot;, middle(&amp;a)-&gt;data);</span>
</pre></div>


<h2 id="5">5.逆序打印链表</h2>
<p>给你链表的头结点, 逆序打印这个链表.使用递归(即让系统使用栈), 时间复杂度O(n)</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">r_display</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">){</span>
        <span class="n">r_display</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2 id="6">6.判断一个链表是否有环</h2>
<p>如果一个链表有环, 那么它肯定只有一个环.(一个相交结点)</p>
<p>算法:设两个指针p, q, 初始化指向头.p以步长2的速度向前跑, q的步长是1.这样, 如果链表不存在环, p和q肯定不会相遇.如果存在环, p和q一定会相遇.(就像两个速度不同的汽车在一个环上跑绝对会相遇).复杂度O(n)</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">any_ring</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//yes</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//fail find</span>
<span class="p">}</span>
</pre></div>


<p>测试:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">e</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">e</span>&quot;<span class="p">,</span> 0<span class="p">},</span> <span class="n">d</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">d</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">},</span> <span class="n">c</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">c</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">b</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="p">=</span> <span class="p">{</span>&quot;<span class="n">a</span>&quot;<span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">e</span><span class="p">.</span><span class="n">next</span> <span class="p">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span> 
<span class="n">printf</span><span class="p">(</span>&quot;<span class="c">%d\n&quot;, any_ring(&amp;a));</span>
</pre></div>


<h2 id="7">7.找出链表中环的入口结点</h2>
<p><img alt="" src="https://github.com/hit9/blog-img-store/raw/master/blog/C/25_0.png" /></p>
<p>还是使用俩指针p和q, p扫描的步长为1, q扫描的步长为2.它们的相遇点为图中meet处(在环上).</p>
<p>假设头指针head到入口点entry之间的距离是K.则当q入环的时候, p已经领先了q为: d = K%n(n为环的周长).</p>
<p>我们设meet处相对entry的距离(沿行进方向)为x, 则有</p>
<p>(n-d)+x = 2x   (p行进的路程是q的两倍)</p>
<p>解得x = n-d</p>
<p>那么当p和q在meet处相遇的时候, 从head处再发出一个步长为1的指针r, 可以知道, r和q会在entry处相遇!</p>
<p>算法就是:</p>
<div class="codehilite"><pre>初始化三个指针<span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span>全部指向<span class="n">head</span><span class="p">.</span> 然后<span class="n">p</span>以2的速度行进<span class="p">,</span> <span class="n">q</span>以1的速度行进<span class="p">.</span>当<span class="n">p</span>和<span class="n">q</span>相遇的时候<span class="p">,</span> 发出<span class="n">r</span>指针并以1的速度行进<span class="p">,</span> 当<span class="n">p</span>和<span class="n">r</span>相遇返回这个结点<span class="p">.</span>复杂度<span class="n">O</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>


<p>代码:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="o">*</span><span class="nf">find_entry</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span> 

    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">q</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//no ring in list</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">r</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">q</span> <span class="o">!=</span> <span class="n">r</span><span class="p">;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 

    <span class="k">return</span> <span class="n">r</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>


<p>测试:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">e</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">},</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">e</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">;</span> 
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">find_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</pre></div>


<h2 id="8">8.判断两个单链表是否相交</h2>
<p>算法:两个指针遍历这两个链表,如果他们的尾结点相同,则必定相交.复杂度O(m+n)</p>
<p>代码实现:</p>
<div class="codehilite"><pre><span class="kt">int</span> <span class="nf">is_intersect</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">node_t</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">a</span> <span class="o">||</span> <span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//a or b is NULL</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
    <span class="k">for</span> <span class="p">(;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">;</span> <span class="c1">//return 1 for yes, 0 for no</span>
<span class="p">}</span>
</pre></div>


<p>测试代码 :</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">e</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">},</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">node_t</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;z&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">},</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">};</span> 
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">is_intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">));</span>
</pre></div>


<h2 id="9">9.找两个链表相交的交点</h2>
<p>假设两个链表a,b.a比b长k个结点(k&gt;=0).</p>
<p>那么当a_ptr,b_ptr两个指针同时分别遍历a,b的时候, 必然b_ptr先到达结尾(NULL),而此时a_ptr落后a的尾巴k个结点.</p>
<p>如果此时再从a的头发出一个指针t,继续和a_ptr 一起走,当a_ptr达到结尾(NULL)时,t恰好走了k个结点.此时从b的头发一个指针s, s和t一起走,因为a比b长k个结点,所以,t和s会一起到达交点.</p>
<p>算法便是:</p>
<div class="codehilite"><pre><span class="n">p</span><span class="p">,</span><span class="n">q</span>分别遍历链表<span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span>假设<span class="n">q</span>先到达<span class="n">NULL</span><span class="p">,</span>此时从<span class="n">a</span>的头发出一个指针<span class="n">t</span><span class="p">,</span>当<span class="n">p</span>到达<span class="n">NULL</span>时<span class="p">,</span>从<span class="n">b</span>的头发出<span class="n">s</span><span class="p">,</span>当<span class="n">s</span><span class="o">==</span><span class="n">t</span>的时候即交点<span class="p">.</span>
</pre></div>


<p>代码实现:
(注,当a,b不相交,函数返回0,即相交在NULL)</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="o">*</span><span class="nf">intersect_point</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">node_t</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 

    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="n">q</span><span class="o">:</span><span class="n">p</span><span class="p">;</span> <span class="c1">//k record the pointer not NULL</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="n">b</span><span class="o">:</span><span class="n">a</span><span class="p">;</span> <span class="c1">//if p arrive at tail first, t = b ; else p = a</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="n">b</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
    <span class="k">for</span> <span class="p">(;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">s</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">t</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>


<p>测试</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">e</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">},</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">node_t</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;z&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">},</span> <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">},</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">};</span> 
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intersect_point</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</pre></div>


<h2 id="10o1">10.O(1)删除结点(不给头结点)</h2>
<p>其实我很反对这个做法.</p>
<p>不给头结点的时候怎么删除一个结点d:</p>
<div class="codehilite"><pre>把<span class="n">d</span>的下一个结点<span class="n">e</span>的数据拷贝到<span class="n">d</span>中<span class="p">,</span>然后删除<span class="n">e</span>
</pre></div>


<p>我认为这是个伪删除,并且这个算法无法处理d是最后一个结点的情况</p>
<p>代码实现:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="o">*</span><span class="nf">delete</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">node_t</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span> 
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>


<h2 id="11">11.两个链表右对齐打印</h2>
<p>为了打印的整齐性,我们把结点存储的数据类型改为int(我们存放数字)</p>
<p>比如两个链表<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>和<code>6-&gt;7-&gt;8</code>,我们想要打印这种效果:</p>
<div class="codehilite"><pre>1 2 3 4 5 
    6 7 8 
</pre></div>


<p>算法:</p>
<div class="codehilite"><pre><span class="n">p</span>和<span class="n">q</span>两个指针分别遍历链表<span class="n">a</span>和<span class="n">b</span><span class="p">,</span>假如<span class="n">q</span>先到达0<span class="p">(</span>即<span class="n">a</span>比<span class="n">b</span>长<span class="p">),</span>此时由<span class="n">a</span>头发出<span class="n">t</span><span class="p">,</span>打印完链表<span class="n">a</span><span class="p">.</span>
<span class="n">p</span>继续移动到0<span class="p">,</span>并打印空格<span class="p">.</span>
从<span class="n">b</span>头发出指针<span class="n">s</span>打印链表<span class="n">b</span>
</pre></div>


<p>代码:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">node_t</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">node_t</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node_t</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 

    <span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">?</span><span class="n">p</span><span class="o">:</span><span class="n">q</span><span class="p">;</span> 
    <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="n">b</span><span class="p">;</span> 
    <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">?</span><span class="n">b</span><span class="o">:</span><span class="n">a</span><span class="p">;</span> 

    <span class="k">for</span> <span class="p">(;</span> <span class="n">t</span><span class="p">;</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span><span class="p">;</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;  &quot;</span><span class="p">),</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span><span class="p">;</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">),</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>


<p>测试:</p>
<div class="codehilite"><pre><span class="n">node_t</span> <span class="n">e</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">},</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">},</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">},</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">};</span> 
<span class="n">node_t</span>  <span class="n">o</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">n</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">},</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">};</span> 
<span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> 
</pre></div>
        </div>
        <div id="foot">
            <a href="javascript:void(0);" onclick="gotopre();">Pre</a>
            <a href="#">Top</a>
            <a href="javascript:void(0);" onclick="gotonext()">Next</a>
        </div>
        <br>
        <!-- Duoshuo Comment BEGIN -->
        <div class="ds-thread" data-thread-key="" 
            data-title="" data-author-key="" data-url=""></div>
        <script type="text/javascript">
            var duoshuoQuery = {short_name:"hit9github"};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = 'http://static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0] 
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
        <!-- Duoshuo Comment END -->
        <div style = "text-align:center; ">
            <p>Support:<a href = "/wiki/mkdwiki">mkdwiki</a></p>
        </div>
    </body>
</html>
